<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>newpapername</title>
    <link href="/2022/10/29/newpapername-1/"/>
    <url>/2022/10/29/newpapername-1/</url>
    
    <content type="html"><![CDATA[<p>hexo new page board</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>newpapername</title>
    <link href="/2022/10/29/newpapername/"/>
    <url>/2022/10/29/newpapername/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>五大基本排序</title>
    <link href="/2022/10/28/hello-world/"/>
    <url>/2022/10/28/hello-world/</url>
    
    <content type="html"><![CDATA[<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs bash">//冒泡排序  <br><span class="hljs-comment">#define _CRT_SECURE_NO_WARNINGS</span><br><span class="hljs-comment">#include&lt;iostream&gt;</span><br><span class="hljs-comment">#include&lt;algorithm&gt;</span><br><br>using namespace std;<br><br>constexpr int N = 110;<br>int b[N];<br><br>void Bubble(int n)<br>&#123;<br><br> <span class="hljs-keyword">for</span> (int i = 0; i &lt; n; i++)<br>  <span class="hljs-keyword">for</span> (int j = i ; j &lt; n; j++)<br>   <span class="hljs-keyword">if</span> (b[j] &lt; b[i]) swap(b[j], b[i]);//升序<br>&#125;<br>int <span class="hljs-function"><span class="hljs-title">main</span></span>()<br>&#123;<br> int n;<br> cin &gt;&gt; n; <br> <span class="hljs-keyword">for</span> (int i = 0; i &lt; n; i++) scanf(<span class="hljs-string">&quot;%d&quot;</span>, &amp;b[i]);<br><br> Bubble(n);<br><br> <span class="hljs-keyword">for</span> (int i = 0; i &lt; n; i++) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, b[i]);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs bash">//选择排序 //SelectSort 每次将当前元素替换为后面最小的元素<br><span class="hljs-comment">#define _CRT_SECURE_NO_WARNINGS</span><br><span class="hljs-comment">#include&lt;iostream&gt;</span><br><span class="hljs-comment">#include&lt;algorithm&gt;</span><br><br>using namespace std;<br><br>constexpr int N = 110;<br>int s[N]; //Selection<br><br>void Selection(int n)<br>&#123;<br> <span class="hljs-keyword">for</span> (int i = 0; i &lt; N; i++)//遍历<br> &#123;<br>  int min = i;//待定<br>  <span class="hljs-keyword">for</span> (int j = i + 1; j &lt; n; j++)//遍历从i+1开始最小的数<br>     <span class="hljs-keyword">if</span> (s[j] &lt; s[min]) min = j;//遍历后，当前min就是最小数的下标<br>                               //如果一直没变过，说明待定那个就是最小的<br><br>  swap(s[i], s[min]);//交换，如果此时i == min ，那就说明当前那个就是最小的<br> &#125;<br><br>&#125;<br><br><br>int <span class="hljs-function"><span class="hljs-title">main</span></span>()<br>&#123;<br> int n;<br> cin &gt;&gt; n;<br> <span class="hljs-keyword">for</span> (int i = 0; i &lt; n; i++) scanf(<span class="hljs-string">&quot;%d&quot;</span>, &amp;s[i]);<br><br> Selection(n);<br><br> <span class="hljs-keyword">for</span> (int i = 0; i &lt; n; i++) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, s[i]);<br> <span class="hljs-built_in">return</span> 0;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="归并"><a href="#归并" class="headerlink" title="归并"></a>归并</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs bash">//归并排序  稳定  <br><span class="hljs-comment">#define _CRT_SECURE_NO_WARNINGS</span><br><span class="hljs-comment">#include&lt;iostream&gt;</span><br><span class="hljs-comment">#include&lt;algorithm&gt;</span><br><br>using namespace std;<br><br>constexpr int N = 110;<br>int m[N] , tmp[N];<br><br>void merge(int m[], int l, int r)<br>&#123;<br> <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-built_in">return</span>;<br><br> int mid = l + r &gt;&gt; 1;<br><br> merge(m, l, mid);<br> merge(m, mid + 1, r);<br><br> int k = 0 , i = l , j = mid + 1;<br><br> <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)<br>  //开始争宠，两边的头谁小谁先进tmp<br>  <span class="hljs-keyword">if</span> (m[i] &lt;= m[j]) tmp[k++] = m[i++];<br>  <span class="hljs-keyword">else</span>              tmp[k++] = m[j++];<br><br> //开始找刚刚争宠后两块中，剩余的部分，没有剩余的就不执行<span class="hljs-keyword">while</span><br> <span class="hljs-keyword">while</span> (i &lt;= mid) tmp[k++] = m[i++];<br> <span class="hljs-keyword">while</span> (j &lt;= r)   tmp[k++] = m[j++];<br><br> //开始把高贵的tmp里面的数据倒入m<br> //为什么i从l开始？因为从n个数据细分到一个，然后合并后，再往上合并，会碰见之前合并过的？<br> //也就是说之前已经有序了，前面的就不用管了？<br> //因为tmp的下标k每次都是0开始，所以会覆盖之前保存的,而且之前的K必定小于之后的K，所以不会出现旧K &gt; 新K<br> //这里是l 不是 1  ， l 和 r 在这个函数里面始终没有变过<br> <span class="hljs-keyword">for</span> (int i = l, j = 0; i &lt;= r; i++, j++) m[i] = tmp[j];<br>&#125;<br><br>int <span class="hljs-function"><span class="hljs-title">main</span></span>()<br>&#123;<br> int n; <br> cin &gt;&gt; n;<br> <span class="hljs-keyword">for</span> (int i = 0; i &lt; n; i++) scanf(<span class="hljs-string">&quot;%d&quot;</span>, &amp;m[i]);<br><br> merge(m, 0, n - 1);<br><br> <span class="hljs-keyword">for</span> (int i = 0; i &lt; n; i++) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span> , m[i]);<br>  <span class="hljs-built_in">return</span> 0;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs bash">//快排，从小到大<br><span class="hljs-comment">#define _CRT_SECURE_NO_WARNINGS</span><br><span class="hljs-comment">#include&lt;iostream&gt;</span><br><span class="hljs-comment">#include&lt;algorithm&gt;</span><br>using namespace std;<br>const int N = 100;<br>int q[N];<br><br>void quick_sort(int q[] , int l , int r)<br>&#123;<br> <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-built_in">return</span>;<br> int x = q[l + r &gt;&gt; 1], i = l - 1, j = r + 1;<br> <span class="hljs-keyword">while</span> (i &lt; j)<br> &#123;<br>  <span class="hljs-keyword">do</span> i++; <span class="hljs-keyword">while</span> (q[i] &lt; x);<br>  <span class="hljs-keyword">do</span> j--; <span class="hljs-keyword">while</span> (q[j] &gt; x);<br>  <span class="hljs-keyword">if</span> (i &lt; j) swap(q[i], q[j]);<br><br> &#125;<br><br> quick_sort(q, l, j);<br> quick_sort(q, j + 1, r);<br>&#125;<br>int <span class="hljs-function"><span class="hljs-title">main</span></span>()<br>&#123;<br> int n;<br> <br> cin &gt;&gt; n;<br> <span class="hljs-keyword">for</span> (int i = 0; i &lt; n; i++) scanf(<span class="hljs-string">&quot;%d&quot;</span>, &amp;q[i]);<br><br> quick_sort(q, 0 , n - 1);<br><br> <span class="hljs-keyword">for</span> (int j = 0; j &lt; n; j++) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,q[j] );<br> <span class="hljs-built_in">return</span> 0;<br>&#125;<br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
